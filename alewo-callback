#!/bin/bash

#######################################
# AlewoCallback - Professional CLI Manager
# Usage: alewo-callback {start|stop|restart|status|logs|help}
#######################################

set -e

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Configuration
INSTALL_DIR="/var/www/alewo-callback"
APP_NAME="alewo-callback"

# Set PM2_HOME to shared location (accessible without sudo)
export PM2_HOME="${PM2_HOME:-/var/www/.pm2}"

# Find PM2 and Node.js binaries
find_node_binaries() {
    # Try common locations
    local NODE_DIRS=(
        "/opt/node22"
        "/opt/node20"
        "/opt/node18"
        "/usr/local"
        "/usr"
    )

    for dir in "${NODE_DIRS[@]}"; do
        if [ -f "$dir/bin/pm2" ]; then
            export NODE_BIN="$dir/bin/node"
            export PM2_BIN="$dir/bin/pm2"
            export NPM_BIN="$dir/bin/npm"
            export PATH="$dir/bin:$PATH"
            return 0
        fi
    done

    # Fallback to PATH
    if command -v pm2 &>/dev/null; then
        export PM2_BIN=$(command -v pm2)
        export NODE_BIN=$(command -v node)
        export NPM_BIN=$(command -v npm)
        return 0
    fi

    return 1
}

# Initialize binaries
if ! find_node_binaries; then
    echo -e "${RED}[ERROR]${NC} PM2 not found. Please install PM2 first."
    echo "Run: npm install -g pm2"
    exit 1
fi

# Load environment variables
if [ -f "$INSTALL_DIR/.env" ]; then
    export $(cat "$INSTALL_DIR/.env" | grep -v '^#' | xargs 2>/dev/null)
fi

# Default values
HTTP_PORT=${PORT:-3000}
DNS_PORT=${DNS_PORT:-53}
NODE_ENV=${NODE_ENV:-production}
BASE_DOMAIN=${BASE_DOMAIN:-localhost}

#######################################
# Logging Functions
#######################################

log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

#######################################
# Banner
#######################################

show_banner() {
    clear
    echo -e "${CYAN}"
    echo "╔═══════════════════════════════════════════════════════════╗"
    echo "║                                                           ║"
    echo "║        █████╗ ██╗     ███████╗██╗    ██╗ ██████╗         ║"
    echo "║       ██╔══██╗██║     ██╔════╝██║    ██║██╔═══██╗        ║"
    echo "║       ███████║██║     █████╗  ██║ █╗ ██║██║   ██║        ║"
    echo "║       ██╔══██║██║     ██╔══╝  ██║███╗██║██║   ██║        ║"
    echo "║       ██║  ██║███████╗███████╗╚███╔███╔╝╚██████╔╝        ║"
    echo "║       ╚═╝  ╚═╝╚══════╝╚══════╝ ╚══╝╚══╝  ╚═════╝         ║"
    echo "║                                                           ║"
    echo "║              CALLBACK SERVICE MANAGER                    ║"
    echo "║                                                           ║"
    echo "╚═══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo ""
}

#######################################
# Helper Functions
#######################################

# Check if PM2 process is running
is_pm2_running() {
    # Method 1 (Most Reliable): Check if ports are listening
    if lsof -Pi :${HTTP_PORT} -sTCP:LISTEN > /dev/null 2>&1 && \
       lsof -Pi :${DNS_PORT} -sUDP > /dev/null 2>&1; then
        # Both HTTP and DNS ports are in use, app is running
        return 0
    fi

    # Method 2: Check via process name (works without PM2 access)
    if pgrep -f "node.*server/index.js" > /dev/null 2>&1; then
        return 0
    fi

    # Method 3: Try PM2 API (least reliable due to PM2_HOME issues)
    if "$PM2_BIN" describe "$APP_NAME" > /dev/null 2>&1; then
        local status=$("$PM2_BIN" jlist 2>/dev/null | grep -o "\"name\":\"$APP_NAME\"[^}]*\"status\":\"[^\"]*\"" | grep -o 'status":"[^"]*"' | cut -d'"' -f3)
        if [ "$status" = "online" ]; then
            return 0
        fi
    fi

    return 1
}

# Get PM2 process uptime (returns uptime in milliseconds)
get_pm2_uptime() {
    # Method 1: Try PM2 API first
    local pm_uptime_timestamp=$("$PM2_BIN" jlist 2>/dev/null | grep -o "\"name\":\"$APP_NAME\"[^}]*\"pm_uptime\":[^,]*" | grep -o 'pm_uptime":[0-9]*' | cut -d':' -f2)

    if [ -n "$pm_uptime_timestamp" ] && [ "$pm_uptime_timestamp" != "0" ]; then
        # Get current time in milliseconds
        local current_time_ms=$(date +%s%3N)
        # Calculate uptime duration
        local uptime_duration=$((current_time_ms - pm_uptime_timestamp))
        echo "$uptime_duration"
        return
    fi

    # Method 2: Fallback - Get uptime from process via ps
    local pid=$(pgrep -f "node.*server/index.js.*alewo-callback" | head -1)
    if [ -n "$pid" ]; then
        # Get process elapsed time in seconds
        local elapsed_sec=$(ps -p "$pid" -o etimes= 2>/dev/null | tr -d ' ')
        if [ -n "$elapsed_sec" ]; then
            # Convert to milliseconds
            echo $((elapsed_sec * 1000))
            return
        fi
    fi

    echo "0"
}

# Format uptime
format_uptime() {
    local uptime_ms=$1
    if [ -z "$uptime_ms" ] || [ "$uptime_ms" = "0" ] || [ "$uptime_ms" -lt "0" ]; then
        echo "just started"
        return
    fi
    local uptime_sec=$((uptime_ms / 1000))
    local days=$((uptime_sec / 86400))
    local hours=$(((uptime_sec % 86400) / 3600))
    local minutes=$(((uptime_sec % 3600) / 60))

    if [ $days -gt 0 ]; then
        echo "${days}d ${hours}h ${minutes}m"
    elif [ $hours -gt 0 ]; then
        echo "${hours}h ${minutes}m"
    else
        echo "${minutes}m"
    fi
}

# Check if port is listening (supports both TCP and UDP)
check_port() {
    local port=$1
    local protocol=${2:-tcp}  # default to tcp if not specified

    if [ "$protocol" = "udp" ]; then
        # Check UDP port (for DNS)
        if command -v ss &>/dev/null; then
            ss -ulnp 2>/dev/null | grep -q ":$port " && return 0
        elif command -v netstat &>/dev/null; then
            netstat -ulnp 2>/dev/null | grep -q ":$port " && return 0
        elif command -v lsof &>/dev/null; then
            lsof -Pi :$port -sUDP 2>/dev/null | grep -q "LISTEN\|UDP" && return 0
        fi
    else
        # Check TCP port (for HTTP/HTTPS)
        if command -v ss &>/dev/null; then
            ss -tlnp 2>/dev/null | grep -q ":$port " && return 0
        elif command -v netstat &>/dev/null; then
            netstat -tlnp 2>/dev/null | grep -q ":$port " && return 0
        elif command -v lsof &>/dev/null; then
            lsof -Pi :$port -sTCP:LISTEN 2>/dev/null | grep -q "LISTEN" && return 0
        fi
    fi

    return 1
}

#######################################
# START Command
#######################################

cmd_start() {
    show_banner
    log_info "Starting AlewoCallback services..."
    echo ""

    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This command must be run as root (use sudo)"
        exit 1
    fi

    # Check if already running
    if is_pm2_running; then
        log_warning "Application is already running"
        echo ""
        cmd_status
        exit 0
    fi

    # Check MongoDB
    if ! systemctl is-active --quiet mongod 2>/dev/null && ! systemctl is-active --quiet mongodb 2>/dev/null; then
        log_info "Starting MongoDB..."
        systemctl start mongod 2>/dev/null || systemctl start mongodb 2>/dev/null
        sleep 2
    fi

    # Start with PM2
    log_info "Starting HTTP/HTTPS Server on port $HTTP_PORT..."
    log_info "Starting DNS Server on port $DNS_PORT..."
    echo ""

    cd "$INSTALL_DIR"

    # Start application with PM2
    "$PM2_BIN" start server/index.js --name "$APP_NAME" > /dev/null 2>&1

    # Wait for startup
    sleep 3

    # Verify startup
    if is_pm2_running; then
        # Health check
        local retries=0
        local max_retries=10
        local health_ok=false

        while [ $retries -lt $max_retries ]; do
            if curl -s -f "http://localhost:$HTTP_PORT/health" > /dev/null 2>&1; then
                health_ok=true
                break
            fi
            sleep 1
            ((retries++))
        done

        if [ "$health_ok" = true ]; then
            log_success "HTTP/HTTPS Server started successfully"
            log_success "DNS Server started successfully"

            echo ""
            echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
            echo -e "${GREEN}║                   SERVICES STARTED                        ║${NC}"
            echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
            echo ""
            echo -e "  ${CYAN}HTTP/HTTPS:${NC} http://localhost:$HTTP_PORT"
            echo -e "  ${CYAN}DNS Server:${NC} Port $DNS_PORT (UDP)"
            echo -e "  ${CYAN}Environment:${NC} $NODE_ENV"
            echo -e "  ${CYAN}Base Domain:${NC} ${BASE_DOMAIN}"
            echo ""
            echo -e "${YELLOW}Commands:${NC}"
            echo -e "  alewo-callback status  - Check service status"
            echo -e "  alewo-callback logs -f - Follow logs in real-time"
            echo ""
        else
            log_error "Service started but health check failed"
            log_info "Check logs: alewo-callback logs"
            exit 1
        fi
    else
        log_error "Failed to start service"
        log_info "Check logs: alewo-callback logs"
        exit 1
    fi
}

#######################################
# STOP Command
#######################################

cmd_stop() {
    show_banner
    log_info "Stopping AlewoCallback services..."
    echo ""

    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This command must be run as root (use sudo)"
        exit 1
    fi

    # Check if running
    if ! is_pm2_running; then
        log_info "Services are not running"
        exit 0
    fi

    # Stop via PM2
    log_info "Stopping HTTP/HTTPS Server..."
    log_info "Stopping DNS Server..."
    echo ""

    "$PM2_BIN" stop "$APP_NAME" > /dev/null 2>&1

    # Verify stopped
    if ! is_pm2_running; then
        log_success "HTTP/HTTPS Server stopped"
        log_success "DNS Server stopped"

        echo ""
        echo -e "${GREEN}╔═══════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║                   SERVICES STOPPED                        ║${NC}"
        echo -e "${GREEN}╚═══════════════════════════════════════════════════════════╝${NC}"
        echo ""
    else
        log_error "Failed to stop services"
        exit 1
    fi
}

#######################################
# RESTART Command
#######################################

cmd_restart() {
    show_banner
    log_info "Restarting AlewoCallback services..."
    echo ""

    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This command must be run as root (use sudo)"
        exit 1
    fi

    # Restart via PM2
    if is_pm2_running; then
        log_info "Restarting HTTP/HTTPS Server..."
        log_info "Restarting DNS Server..."
        echo ""

        "$PM2_BIN" restart "$APP_NAME" > /dev/null 2>&1
        sleep 2

        if is_pm2_running; then
            log_success "Services restarted successfully"
            echo ""
            cmd_status
        else
            log_error "Failed to restart services"
            exit 1
        fi
    else
        log_warning "Services are not running. Starting instead..."
        cmd_start
    fi
}

#######################################
# STATUS Command
#######################################

cmd_status() {
    show_banner

    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                   SERVICE STATUS                          ║${NC}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    # HTTP/HTTPS Server Status
    echo -e "${YELLOW}HTTP/HTTPS Server:${NC}"
    if is_pm2_running; then
        local uptime_ms=$(get_pm2_uptime)
        local uptime=$(format_uptime $uptime_ms)

        echo -e "  Status: ${GREEN}● Running${NC}"
        echo -e "  Uptime: $uptime"
        echo -e "  Port: $HTTP_PORT"

        if check_port "$HTTP_PORT"; then
            echo -e "  Listening: ${GREEN}✓${NC}"
        else
            echo -e "  Listening: ${RED}✗${NC}"
        fi
    else
        echo -e "  Status: ${RED}● Stopped${NC}"
    fi

    echo ""

    # DNS Server Status
    echo -e "${YELLOW}DNS Server:${NC}"
    if is_pm2_running && check_port "$DNS_PORT" "udp"; then
        echo -e "  Status: ${GREEN}● Running${NC}"
        echo -e "  Port: $DNS_PORT (UDP)"
    else
        if is_pm2_running; then
            echo -e "  Status: ${YELLOW}● Process running, port check inconclusive${NC}"
            echo -e "  Port: $DNS_PORT (UDP)"
        else
            echo -e "  Status: ${RED}● Stopped${NC}"
        fi
    fi

    echo ""

    # MongoDB Status
    echo -e "${YELLOW}MongoDB:${NC}"
    if systemctl is-active --quiet mongod 2>/dev/null || systemctl is-active --quiet mongodb 2>/dev/null; then
        echo -e "  Status: ${GREEN}● Running${NC}"
    else
        echo -e "  Status: ${RED}● Stopped${NC}"
    fi

    echo ""

    # Configuration
    echo -e "${CYAN}╔═══════════════════════════════════════════════════════════╗${NC}"
    echo -e "${CYAN}║                   CONFIGURATION                           ║${NC}"
    echo -e "${CYAN}╚═══════════════════════════════════════════════════════════╝${NC}"
    echo ""

    echo -e "  Environment: ${NODE_ENV}"
    echo -e "  HTTP Port: ${HTTP_PORT}"
    echo -e "  DNS Port: ${DNS_PORT}"
    echo -e "  Base Domain: ${BASE_DOMAIN}"
    echo -e "  SSL Enabled: ${SSL_ENABLED:-false}"
    echo -e "  Install Dir: ${INSTALL_DIR}"
    echo -e "  PM2 Home: ${PM2_HOME} ${GREEN}(no sudo required)${NC}"

    echo ""
}

#######################################
# LOGS Command
#######################################

cmd_logs() {
    local follow=false
    local lines=50
    local error_only=false

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -f|--follow)
                follow=true
                shift
                ;;
            -e|--error)
                error_only=true
                shift
                ;;
            -n|--lines)
                lines="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done

    # Show logs via PM2
    if [ "$follow" = true ]; then
        "$PM2_BIN" logs "$APP_NAME" --lines "$lines"
    elif [ "$error_only" = true ]; then
        "$PM2_BIN" logs "$APP_NAME" --err --lines "$lines" --nostream
    else
        "$PM2_BIN" logs "$APP_NAME" --lines "$lines" --nostream
    fi
}

#######################################
# UNINSTALL Command
#######################################

cmd_uninstall() {
    clear
    echo -e "${RED}"
    echo "╔═══════════════════════════════════════════════════════════╗"
    echo "║              ALEWO CALLBACK UNINSTALLER                  ║"
    echo "║              ⚠️  THIS WILL REMOVE ALL DATA  ⚠️            ║"
    echo "╚═══════════════════════════════════════════════════════════╝"
    echo -e "${NC}"
    echo ""
    echo -e "${YELLOW}This will remove:${NC}"
    echo "  • Application files and configuration"
    echo "  • MongoDB database (alewo-callback)"
    echo "  • SSL certificates (if installed)"
    echo "  • Nginx configuration"
    echo "  • Cron jobs for certificate renewal"
    echo "  • Firewall rules"
    echo "  • PM2 processes"
    echo ""
    echo -e "${CYAN}This will NOT remove:${NC}"
    echo "  • Node.js, MongoDB, Nginx, PM2 (system packages)"
    echo "  • System-wide configurations"
    echo ""

    read -p "$(echo -e ${YELLOW}Are you sure you want to continue? ${NC}[y/N]: )" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        log_info "Uninstallation cancelled"
        exit 0
    fi

    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        log_error "This command must be run as root (use sudo)"
        exit 1
    fi

    echo ""
    log_info "Starting complete uninstallation..."
    echo ""

    # 1. Stop PM2 processes
    log_info "Stopping PM2 processes..."
    "$PM2_BIN" delete "$APP_NAME" 2>/dev/null || true
    "$PM2_BIN" kill 2>/dev/null || true
    log_success "PM2 processes stopped"

    # 2. Remove systemd services
    log_info "Removing systemd services..."
    systemctl stop pm2-root 2>/dev/null || true
    systemctl disable pm2-root 2>/dev/null || true
    rm -f /etc/systemd/system/pm2-root.service
    systemctl daemon-reload 2>/dev/null || true
    log_success "Systemd services removed"

    # 3. Remove application files
    log_info "Removing application files..."
    rm -rf "$INSTALL_DIR"
    log_success "Application files removed"

    # 4. Remove management command
    log_info "Removing management command..."
    rm -f /usr/local/bin/alewo-callback
    log_success "Management command removed"

    # 5. Remove Nginx configuration
    log_info "Removing Nginx configuration..."
    rm -f /etc/nginx/sites-enabled/alewo-callback
    rm -f /etc/nginx/sites-available/alewo-callback
    systemctl reload nginx 2>/dev/null || true
    log_success "Nginx configuration removed"

    # 6. Drop MongoDB database
    log_info "Dropping MongoDB database..."
    if command -v mongosh &> /dev/null; then
        mongosh --quiet --eval "db.getSiblingDB('alewo-callback').dropDatabase()" 2>/dev/null || log_warning "Could not drop database with mongosh"
    elif command -v mongo &> /dev/null; then
        mongo alewo-callback --quiet --eval "db.dropDatabase()" 2>/dev/null || log_warning "Could not drop database with mongo"
    else
        log_warning "MongoDB client not found, skipping database drop"
    fi
    log_success "MongoDB database dropped"

    # 7. Remove SSL certificates
    log_info "Removing SSL certificates..."

    # Remove Let's Encrypt certificates
    if [ -d "/etc/letsencrypt/live" ]; then
        # Find and remove all certificates for this installation
        for domain in /etc/letsencrypt/live/*; do
            if [ -d "$domain" ]; then
                domain_name=$(basename "$domain")
                log_info "  Removing Let's Encrypt certificate for: $domain_name"
                certbot delete --cert-name "$domain_name" --non-interactive 2>/dev/null || true
            fi
        done
    fi

    # Remove Cloudflare/acme.sh certificates
    if [ -d "/etc/nginx/ssl" ]; then
        log_info "  Removing Cloudflare/acme.sh certificates..."
        rm -rf /etc/nginx/ssl 2>/dev/null || true
    fi

    # Remove self-signed certificates
    rm -rf /etc/ssl/alewo-callback 2>/dev/null || true

    # Remove acme.sh installation (optional - ask user)
    if [ -d "/root/.acme.sh" ]; then
        read -p "$(echo -e ${YELLOW}Remove acme.sh installation? ${NC}[y/N]: )" -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "  Removing acme.sh..."
            /root/.acme.sh/acme.sh --uninstall 2>/dev/null || true
            rm -rf /root/.acme.sh 2>/dev/null || true
            log_success "acme.sh removed"
        else
            log_info "  Keeping acme.sh installation"
        fi
    fi

    log_success "SSL certificates removed"

    # 8. Remove cron jobs
    log_info "Removing cron jobs..."
    (crontab -l 2>/dev/null | grep -v "certbot renew" | grep -v "alewo-callback" | grep -v "acme.sh") | crontab - 2>/dev/null || true
    log_success "Cron jobs removed"

    # 9. Restore systemd-resolved (ONLY if installer disabled it)
    log_info "Checking DNS configuration..."

    # Check if installer modified systemd-resolved
    DNS_STATE_FILE="/var/lib/alewo-callback/dns-state"
    if [ -f "$DNS_STATE_FILE" ]; then
        # Load saved state
        source "$DNS_STATE_FILE"

        if [ "$SYSTEMD_RESOLVED_DISABLED_BY_INSTALLER" = "true" ]; then
            log_info "  Installer disabled systemd-resolved, restoring..."

            # Remove immutable flag from resolv.conf
            chattr -i /etc/resolv.conf 2>/dev/null || true

            # Re-enable systemd-resolved FIRST (before removing resolv.conf)
            systemctl enable systemd-resolved 2>/dev/null || true
            systemctl start systemd-resolved 2>/dev/null || true

            # Wait for systemd-resolved to be ready
            sleep 2

            # Only recreate resolv.conf if systemd-resolved is running
            if systemctl is-active --quiet systemd-resolved; then
                rm -f /etc/resolv.conf

                # Restore original resolv.conf if backup exists
                if [ -n "$RESOLV_CONF_BACKUP" ] && [ -e "$RESOLV_CONF_BACKUP" ]; then
                    ln -sf "$RESOLV_CONF_BACKUP" /etc/resolv.conf 2>/dev/null || true
                    log_success "  Restored original resolv.conf: $RESOLV_CONF_BACKUP"
                else
                    # Fallback to default systemd-resolved path
                    ln -sf /run/systemd/resolve/stub-resolv.conf /etc/resolv.conf 2>/dev/null || true
                    log_success "  Restored default systemd-resolved config"
                fi

                log_success "systemd-resolved restored successfully"
            else
                # Fallback: Keep manual DNS config if systemd-resolved fails
                log_warning "systemd-resolved failed to start"
                log_info "  Keeping manual DNS configuration (no changes to /etc/resolv.conf)"
            fi

            # Remove state file after successful restore
            rm -f "$DNS_STATE_FILE"
        else
            log_info "  systemd-resolved was not disabled by installer, skipping restore"
        fi
    else
        log_info "  No DNS state file found - installer did not modify systemd-resolved"
        log_info "  Skipping DNS restoration (no changes to /etc/resolv.conf)"
    fi

    # Remove state directory if empty
    rmdir /var/lib/alewo-callback 2>/dev/null || true

    # 10. Remove firewall rules (optional - ask user)
    echo ""
    read -p "$(echo -e ${YELLOW}Remove firewall rules for ports 80, 443, 53? ${NC}[y/N]: )" -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        log_info "Removing firewall rules..."
        if command -v ufw &> /dev/null; then
            ufw delete allow 80/tcp 2>/dev/null || true
            ufw delete allow 443/tcp 2>/dev/null || true
            ufw delete allow 53/udp 2>/dev/null || true
            log_success "Firewall rules removed"
        else
            log_info "UFW not found, skipping firewall cleanup"
        fi
    else
        log_info "Keeping firewall rules"
    fi

    # 11. Clean up temporary files
    log_info "Cleaning up temporary files..."
    rm -f /tmp/alewo-callback-* 2>/dev/null || true
    log_success "Temporary files cleaned"

    echo ""
    log_success "═══════════════════════════════════════════════════════"
    log_success "AlewoCallback has been completely uninstalled!"
    log_success "═══════════════════════════════════════════════════════"
    echo ""
    echo -e "${CYAN}Note:${NC} System packages (Node.js, MongoDB, Nginx) are still installed."
    echo -e "${CYAN}To remove them, run:${NC}"
    echo "  sudo apt remove --purge nodejs mongodb-org* nginx certbot -y"
    echo "  sudo apt autoremove -y"
    echo ""
}

#######################################
# HELP Command
#######################################

cmd_help() {
    show_banner

    echo -e "${CYAN}USAGE:${NC}"
    echo -e "  alewo-callback [COMMAND] [OPTIONS]"
    echo ""
    echo -e "${CYAN}COMMANDS:${NC}"
    echo -e "  ${GREEN}start${NC}      Start all services (requires sudo)"
    echo -e "  ${GREEN}stop${NC}       Stop all services (requires sudo)"
    echo -e "  ${GREEN}restart${NC}    Restart all services (requires sudo)"
    echo -e "  ${GREEN}status${NC}     Show service status"
    echo -e "  ${GREEN}logs${NC}       View application logs"
    echo -e "  ${GREEN}uninstall${NC}  Remove AlewoCallback (requires sudo)"
    echo -e "  ${GREEN}help${NC}       Show this help message"
    echo ""
    echo -e "${CYAN}LOG OPTIONS:${NC}"
    echo -e "  ${YELLOW}-f, --follow${NC}     Follow log output in real-time"
    echo -e "  ${YELLOW}-e, --error${NC}      Show only error logs"
    echo -e "  ${YELLOW}-n, --lines N${NC}    Show last N lines (default: 50)"
    echo ""
    echo -e "${CYAN}EXAMPLES:${NC}"
    echo -e "  sudo alewo-callback start"
    echo -e "  alewo-callback status"
    echo -e "  alewo-callback logs -f"
    echo -e "  alewo-callback logs --error --lines 100"
    echo ""
}

#######################################
# Main
#######################################

# Parse command
case "${1:-help}" in
    start)
        cmd_start
        ;;
    stop)
        cmd_stop
        ;;
    restart)
        cmd_restart
        ;;
    status)
        cmd_status
        ;;
    logs)
        shift
        cmd_logs "$@"
        ;;
    uninstall)
        cmd_uninstall
        ;;
    help|--help|-h)
        cmd_help
        ;;
    *)
        log_error "Unknown command: $1"
        echo ""
        cmd_help
        exit 1
        ;;
esac
